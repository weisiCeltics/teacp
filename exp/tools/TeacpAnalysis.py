#!/usr/bin/python

###-----------------------------------------------------------------------------
### The TeaCP post-experiment analysis component
###
### Usage: analysis_tool = TeacpAnalysis(log_dir, log_format)
###
### log_dir:      the directory containing the log files.
###               Be careful if you use relative path. The relative path
###               should be described from the current working directory of
###               the calling script.
### log_format:   options - 'exp', 'sim'
###               If the format is 'exp', then the TeaCP analysis component
###               parses the log files in the format of experiments'
###               log files. Otherwise in the format of simulations' log
###               files.
###
### Key functions:
###     
###     calc_all():                  calculate all the statistics for each node
###                                  and the whole network
###     print_result():              print the statistics on the screen
###     print_result_to_file():      write the statistics into a file
###     draw_delay_histogram():      draw the delay distribution for all the 
###                                  nodes and save the graph as a png file
###     create_topology_animation(): create the animation of the network 
###                                  topology
###-----------------------------------------------------------------------------


import sys
import os
import gc
import operator
import matplotlib.pyplot as plt
import math
from numpy import array
from numpy import correlate
import numpy as np

import glob
import time
import pydot
import random


"""
    The TeaCP analysis component first parses the log files obtained from
    experiments/simulations and collect information about packets (contained
    in the class member variable |packets[src_node][pkt_id]|):

    'birth_time':      the time when the packet is generated by its
                       source node
    'delivery_time':   the time when the packets is delivered to the
                       root node
    'delivered_count': how many times that the packet is delivered to
                       the root node. If it is more than one, then
                       duplicates have been delivered.
    'delay':           the time elapsing from the packet's birth to its
                       delivery, i.e., delivery_time - birth_time
    'hopcount':        how many hops the packet has experienced until
                       delivery
    'trace':           recording each intermediate node that the packet
                       has traversed


    Then the TeaCP analysis component calculates the following statistics for 
    each source node (contained in the class member variable 
    |node_statistics[src_node]|):

    'num_pkts_generated':           the number of packets generated by the source
                                    node
    'num_pkts_delivered':           the number of delivered packets generated by
                                    the source node
    'num_pkts_delivered_dup':       the number of delivered packets including
                                    duplicates
    'num_pkts_undelivered':         the number of lost packets generated by the
                                    source node
    'avg_delay':                    the average delay for the delivered pacekts
    'throughput':                   the average number of delivered packets
                                    (including duplicates) per second
    'goodput':                      the average number of delivered unique
                                    packets (excluding duplicates) per second
    'avg_hopcount':                 the average hop count for the delivered
                                    packets
    'delivery_rate':                the percentage of the delivered packets in
                                    the generated packets
    'num_pkts_generated_range':     the number of generated packets in the 
                                    packet ID range
    'num_pkts_delivered_range':     the number of delivered packets in the
                                    packet ID range
    'num_pkts_delivered_dup_range': the number of delivered packets (including
                                    duplicates) in the packet ID range
    'num_pkts_undelivered_range':   the number of lost packets in the packet
                                    ID range


    The TeaCP analysis component also calculates the following statistics for 
    the whole network (contained in the class member variable 
    |network_statistics|):

    'num_pkts_generated':           the number of packets generated by the whole 
                                    network
    'num_pkts_delivered':           the number of delivered unique packets 
                                    (excluding duplicates)
    'num_pkts_delivered_dup':       the number of delivered packets including
                                    duplicates
    'num_pkts_undelivered':         the number of lost packets for the whole
                                    network
    'avg_delay':                    the average delay for the delivered pacekts
    'throughput':                   the average number of delivered packets
                                    (including duplicates) per second
    'goodput':                      the average number of delivered unique
                                    packets (excluding duplicates) per second
    'avg_hopcount':                 the average hop count for the delivered
                                    packets
    'delivery_rate':                the percentage of the delivered packets in
                                    the generated packets
    'test_duration':                the duration of the test
    'num_pkts_generated_range':     the number of generated packets in the 
                                    packet ID range
    'num_pkts_delivered_range':     the number of delivered packets in the
                                    packet ID range
    'num_pkts_delivered_dup_range': the number of delivered packets (including
                                    duplicates) in the packet ID range
    'num_pkts_undelivered_range':   the number of lost packets in the packet
                                    ID range
"""


class TeacpAnalysis:
    
    def __init__(self, log_dir, log_format):

        self.log_dir = log_dir
        self.src_node_list = []
        self.packets = {}
        self.node_statistics = {}
        self.min_pkt_id = 0
        self.max_pkt_id = 0

        ### Parameters for visualizing network topology animation
        self.node_position = {}
        self.node_color = {} 
        self.image_size = '10,10'
        self.segment_size = 10
        self.save_frame = True
        self.image_only = False

        self.network_statistics = {
            'num_pkts_generated': 0,
            'num_pkts_delivered': 0,
            'num_pkts_delivered_dup': 0,
            'num_pkts_undelivered': 0,
            'avg_delay': 0,
            'avg_hopcount': 0,
            'delivery_rate': 0,
            'throughput': 0,
            'goodput': 0,
            'test_duration': 0,
            'num_pkts_generated_range': 0,
            'num_pkts_delivered_range': 0,
            'num_pkts_delivered_dup_range': 0,
            'num_pkts_undelivered_range': 0
            }

        test_has_started = False
        test_start_time = 0
        test_finish_time = 0

        ### Read all the files with file name extension .log in the directory
        for log_file_name in glob.glob(log_dir + '*.log'):

            log_file = open(log_file_name, 'r')
            log_file_lines = log_file.readlines()

            for line in log_file_lines:

                ### Extract a log message from each line of the log files based
                ### on the recording format, i.e., from experiments or from
                ### simulations
                if (log_format == 'exp'):

                    s = line.split()

                    if (len(s) != 24):
                        continue

                    event_type = int(s[8], 16)
                    cur_node   = int(s[9]+s[10], 16)
                    src_node   = int(s[11]+s[12], 16)
                    last_node  = int(s[13]+s[14], 16)
                    pkt_id     = int(s[15]+s[16]+s[17]+s[18], 16)
                    event_time = int(s[19]+s[20]+s[21]+s[22], 16) * 500 / 512
                    hop_count  = int(s[23], 16)

                else:

                    s = line.split(':')[3].strip().split(',')

                    event_type = int(s[0])
                    cur_node   = int(s[1])
                    src_node   = int(s[2])
                    last_node  = int(s[3])
                    pkt_id     = int(s[4])
                    event_time = int(s[5]) * 500 / 512
                    hop_count  = int(s[6])


                ### Create a record for each packet
                if (src_node not in self.src_node_list):
                    
                    self.src_node_list.append(src_node)
                    self.packets[src_node] = {}
                    self.node_statistics[src_node] = {}

                if (pkt_id not in self.packets[src_node]):
                    
                    self.packets[src_node][pkt_id] = {
                        'birth_time': event_time,
                        'delivery_time': 0,
                        'delivered_count': 0,
                        'delay': 0,
                        'hopcount': 0,
                        'trace': []
                        }
                    
                ### The event of packet generation at the source node 
                if (event_type == 0): 
                    
                    self.packets[src_node][pkt_id]['birth_time'] = event_time
                    self.packets[src_node][pkt_id]['trace'].append((cur_node, last_node, event_time, hop_count))
                    
                ### The event of packet reception at sensor (non-root) nodes  
                elif (event_type == 1): 
                                    
                    self.packets[src_node][pkt_id]['trace'].append((cur_node, last_node, event_time, hop_count))
                        
                ### The event of packet reception at the root node 
                elif (event_type == 2): 
                                    
                    self.packets[src_node][pkt_id]['trace'].append((cur_node, last_node, event_time, hop_count))

                    ### Update the delivery time if the packet has been
                    ### delivered before
                    if (self.packets[src_node][pkt_id]['delivery_time'] > event_time or 
                        self.packets[src_node][pkt_id]['delivered_count'] == 0):
                        
                        self.packets[src_node][pkt_id]['delivery_time'] = event_time
                        self.packets[src_node][pkt_id]['hopcount'] = hop_count
                    
                    ### Increment the count of how many times the packet has
                    ### been received by the root node
                    self.packets[src_node][pkt_id]['delivered_count'] += 1
                

                if (event_time < 0):
                    continue
                
                ### Recording the starting and finishting time of simulations
                ### Recording the smallest and largest packet ID in the
                ### simulation
                if (not test_has_started):
                    test_start_time = event_time
                    self.min_pkt_id = pkt_id
                    test_has_started = True
                
                if (test_start_time > event_time):
                    test_start_time = event_time

                if (test_finish_time < event_time):
                    test_finish_time = event_time

                if (self.min_pkt_id > pkt_id):
                    self.min_pkt_id = pkt_id

                if (self.max_pkt_id < pkt_id):
                    self.max_pkt_id = pkt_id

            log_file.close()

        self.network_statistics['test_duration'] = test_finish_time - test_start_time
        self.src_node_list.sort()
                

    ###------------------------------------------------------------------------
    ### The functions for configuring the parameters in the analysis
    ###------------------------------------------------------------------------

    def set_pkt_range(self, pkt_range):

        self.min_pkt_id = pkt_range[0]
        self.max_pkt_id = pkt_range[1]


    ###------------------------------------------------------------------------
    ### The functions for calculating the statistics
    ###------------------------------------------------------------------------
    
    ### Calculate the statistics in one function
    def calc_all(self):

        self.calc_delay()
        self.calc_num_packets()
        self.calc_num_packets_range()

        self.calc_avg_delay()
        self.calc_median_delay()
        self.calc_max_delay()
        self.calc_avg_delay_percentage(95)
        self.calc_avg_hopcount()
        self.calc_delivery_rate()
        self.calc_throughput()
        self.calc_goodput()


    ### Adjust the packet traces
    def adjust_packet_trace(self):
    
        for src_node in self.packets:
            for pkt_id in self.packets[src_node]:
                self.packets[src_node][pkt_id]['trace'].sort(key=itemgetter(2)) # sort the events by time
       

    ### Calculate the delay for the delivered packets
    def calc_delay(self):

        for src_node in self.packets: 

            for pkt_id in self.packets[src_node]:

                if (self.packets[src_node][pkt_id]['delivered_count'] > 0):

                    self.packets[src_node][pkt_id]['delay'] = (
                        self.packets[src_node][pkt_id]['delivery_time'] - 
                        self.packets[src_node][pkt_id]['birth_time'] )

                    #if (self.packets[src_node][pkt_id]['delay'] < 0):
                    #    print src_node, pkt_id, self.packets[src_node][pkt_id]
                                                         

    ### Calculate the number of packets that generated, delivered and undelivered
    def calc_num_packets(self):
        
        num_pkts_generated_network = 0
        num_pkts_delivered_network = 0
        num_pkts_delivered_dup_network = 0
        
        for src_node in self.packets:
            
            num_pkts_generated_node = 0
            num_pkts_delivered_node = 0
            num_pkts_delivered_dup_node = 0

            for pkt_id in self.packets[src_node]:
                    
                num_pkts_generated_node += 1

                if (self.packets[src_node][pkt_id]['delivered_count'] > 0):

                    num_pkts_delivered_node += 1
                    num_pkts_delivered_dup_node += self.packets[src_node][pkt_id]['delivered_count']

            self.node_statistics[src_node]['num_pkts_generated'] = num_pkts_generated_node
            self.node_statistics[src_node]['num_pkts_delivered'] = num_pkts_delivered_node
            self.node_statistics[src_node]['num_pkts_delivered_dup'] = num_pkts_delivered_dup_node
            self.node_statistics[src_node]['num_pkts_undelivered'] = (num_pkts_generated_node 
                                                  - num_pkts_delivered_node)
            
            num_pkts_generated_network += num_pkts_generated_node
            num_pkts_delivered_network += num_pkts_delivered_node
            num_pkts_delivered_dup_network += num_pkts_delivered_dup_node

        self.network_statistics['num_pkts_generated'] = num_pkts_generated_network
        self.network_statistics['num_pkts_delivered'] = num_pkts_delivered_network
        self.network_statistics['num_pkts_delivered_dup'] = num_pkts_delivered_dup_network
        self.network_statistics['num_pkts_undelivered'] = (num_pkts_generated_network
                                         - num_pkts_delivered_network)


    ### Calculate the number of packets that generated, delivered and undelivered
    def calc_num_packets_range(self):
        
        num_pkts_generated_network = 0
        num_pkts_delivered_network = 0
        num_pkts_delivered_dup_network = 0
        
        for src_node in self.packets:
            
            num_pkts_generated_node = 0
            num_pkts_delivered_node = 0
            num_pkts_delivered_dup_node = 0

            for pkt_id in range(self.min_pkt_id, self.max_pkt_id):
            
                if (pkt_id in self.packets[src_node]):
                    
                    num_pkts_generated_node += 1

                    if (self.packets[src_node][pkt_id]['delivered_count'] > 0):

                        num_pkts_delivered_node += 1
                        num_pkts_delivered_dup_node += self.packets[src_node][pkt_id]['delivered_count']

            self.node_statistics[src_node]['num_pkts_generated_range'] = num_pkts_generated_node
            self.node_statistics[src_node]['num_pkts_delivered_range'] = num_pkts_delivered_node
            self.node_statistics[src_node]['num_pkts_delivered_dup_range'] = num_pkts_delivered_dup_node
            self.node_statistics[src_node]['num_pkts_undelivered_range'] = (num_pkts_generated_node 
                                                  - num_pkts_delivered_node)
            
            num_pkts_generated_network += num_pkts_generated_node
            num_pkts_delivered_network += num_pkts_delivered_node
            num_pkts_delivered_dup_network += num_pkts_delivered_dup_node

        self.network_statistics['num_pkts_generated_range'] = num_pkts_generated_network
        self.network_statistics['num_pkts_delivered_range'] = num_pkts_delivered_network
        self.network_statistics['num_pkts_delivered_dup_range'] = num_pkts_delivered_dup_network
        self.network_statistics['num_pkts_undelivered_range'] = (num_pkts_generated_network
                                         - num_pkts_delivered_network)
    

    ### Calculate the average delay for each node and the whole network
    def calc_avg_delay(self):

        sum_delay_network = 0

        for src_node in self.packets:

            sum_delay_node = 0

            for pkt_id in range(self.min_pkt_id, self.max_pkt_id):
                
                if (pkt_id in self.packets[src_node]):
                    if (self.packets[src_node][pkt_id]['delivered_count'] > 0):
                        sum_delay_node += self.packets[src_node][pkt_id]['delay']

            self.node_statistics[src_node]['avg_delay'] = float(sum_delay_node) / \
                                  self.node_statistics[src_node]['num_pkts_delivered_range']

            sum_delay_network = sum_delay_network + sum_delay_node

        self.network_statistics['avg_delay'] = float(sum_delay_network) / \
                                       self.network_statistics['num_pkts_delivered_range']

    
    ### Calculate the median delay for each node and the whole network
    def calc_median_delay(self):
        
        delay_list_network = []

        for src_node in self.packets:

            delay_list_node = []

            for pkt_id in range(self.min_pkt_id, self.max_pkt_id):

                if (pkt_id in self.packets[src_node]):
                    if (self.packets[src_node][pkt_id]['delivered_count'] > 0):
                        delay_list_node.append(self.packets[src_node][pkt_id]['delay'])

            self.node_statistics[src_node]['median_delay'] = np.median(array(delay_list_node))

            delay_list_network.extend(delay_list_node)

        self.network_statistics['median_delay'] = np.median(array(delay_list_network))
        
        return


    ### Calculate the maximum delay for each node and the whole network
    def calc_max_delay(self):
        
        delay_list_network = []

        for src_node in self.packets:

            delay_list_node = []

            for pkt_id in range(self.min_pkt_id, self.max_pkt_id):

                if (pkt_id in self.packets[src_node]):
                    if (self.packets[src_node][pkt_id]['delivered_count'] > 0):
                        delay_list_node.append(self.packets[src_node][pkt_id]['delay'])

            self.node_statistics[src_node]['max_delay'] = max(delay_list_node)

            delay_list_network.extend(delay_list_node)

        self.network_statistics['max_delay'] = max(delay_list_network)

        return


    ### Calculate the average delay for a percentage of packets with lowest
    ### delay. In other words, the calculation excludes a portion of high
    ### delay packets (1-percentage/100).
    def calc_avg_delay_percentage(self, percentage):
        
        if (percentage <= 1 or percentage > 100):
            print "Error: invalid percentage."
            return
        
        delay_list_network = []

        for src_node in self.packets:

            delay_list_node = []

            for pkt_id in range(self.min_pkt_id, self.max_pkt_id):

                if (pkt_id in self.packets[src_node]):
                    if (self.packets[src_node][pkt_id]['delivered_count'] > 0):
                        delay_list_node.append(self.packets[src_node][pkt_id]['delay'])

            delay_list_node.sort()

            max_idx = int(len(delay_list_node) * percentage / 100)

            self.node_statistics[src_node]['avg_delay_perc'+str(percentage)] = \
                    float(sum(delay_list_node[0:max_idx])) / max_idx

            delay_list_network.extend(delay_list_node)

        delay_list_network.sort()

        max_idx = int(len(delay_list_network) * percentage / 100)

        self.network_statistics['avg_delay_perc'+str(percentage)] = \
                float(sum(delay_list_network[0:max_idx])) / max_idx

        return


    ### Calculate the average hop count for each node and the whole network
    def calc_avg_hopcount(self):

        sum_hopcount_network = 0

        for src_node in self.packets:

            sum_hopcount_node = 0

            for pkt_id in range(self.min_pkt_id, self.max_pkt_id):
                
                if (pkt_id in self.packets[src_node]):

                    if (self.packets[src_node][pkt_id]['delivered_count'] > 0):
                        sum_hopcount_node += self.packets[src_node][pkt_id]['hopcount']

            self.node_statistics[src_node]['avg_hopcount'] = float(sum_hopcount_node) / \
                                        self.node_statistics[src_node]['num_pkts_delivered_range']

            sum_hopcount_network += sum_hopcount_node

        self.network_statistics['avg_hopcount'] = float(sum_hopcount_network) / \
                                  self.network_statistics['num_pkts_delivered_range']


    ### Calculate throughput for each node and the whole network
    def calc_throughput(self):

        for src_node in self.src_node_list:

            self.node_statistics[src_node]['throughput'] = (self.node_statistics[src_node]['num_pkts_delivered_dup']
                                          / float(self.network_statistics['test_duration']) * 1000)

        self.network_statistics['throughput'] = (self.network_statistics['num_pkts_delivered_dup']
                               / float(self.network_statistics['test_duration']) * 1000)


    ### Calculate goodput for each node and the whole network
    def calc_goodput(self):
        
        for src_node in self.src_node_list:

            self.node_statistics[src_node]['goodput'] = (self.node_statistics[src_node]['num_pkts_delivered']
                                          / float(self.network_statistics['test_duration']) * 1000)

        self.network_statistics['goodput'] = (self.network_statistics['num_pkts_delivered']
                               / float(self.network_statistics['test_duration']) * 1000)
                    
                        
    ### Calculate the delivery rate for each node and the whole network
    def calc_delivery_rate(self):

        for src_node in self.src_node_list:

            self.node_statistics[src_node]['delivery_rate'] = (self.node_statistics[src_node]['num_pkts_delivered_range']
                                    / float(self.node_statistics[src_node]['num_pkts_generated_range']))

        self.network_statistics['delivery_rate'] = (self.network_statistics['num_pkts_delivered_range']
                                    / float(self.network_statistics['num_pkts_generated_range']))


    ### Print the analysis results and write them to result.txt
    def print_result(self):

        print '\nTest duration:', self.network_statistics['test_duration'] / 1000, 'seconds'
        print 'Number of sensor (source) nodes:', len(self.src_node_list)
        print 'Packet ID range:', self.min_pkt_id, '->', self.max_pkt_id
        print '\n-----Node statistics-----'
        print '  NodeID   #Generated   #Delivered   AvgHops   AvgDelay   Delivery%   Throughput   Goodput'
        for src_node in self.src_node_list:
            print ('{:8d} {:12d} {:12d} {:9.2f} {:10.2f} {:11.2f} {:12.2f} {:9.2f}').format(src_node, 
                   self.node_statistics[src_node]['num_pkts_generated_range'],
                   self.node_statistics[src_node]['num_pkts_delivered_range'],
                   self.node_statistics[src_node]['avg_hopcount'],
                   self.node_statistics[src_node]['avg_delay'],
                   self.node_statistics[src_node]['delivery_rate'] * 100,
                   self.node_statistics[src_node]['throughput'],
                   self.node_statistics[src_node]['goodput'])

        print '\n-----Network statistics-----'
        print '           #Generated   #Delivered   AvgHops   AvgDelay   Delivery%   Throughput   Goodput'
        print ('         {:12d} {:12d} {:9.2f} {:10.2f} {:11.2f} {:12.2f} {:9.2f}').format(
               self.network_statistics['num_pkts_generated_range'],
               self.network_statistics['num_pkts_delivered_range'],
               self.network_statistics['avg_hopcount'],
               self.network_statistics['avg_delay'],
               self.network_statistics['delivery_rate'] * 100,
               self.network_statistics['throughput'],
               self.network_statistics['goodput'])
        print ''


    ### Write the analysis results to a file (by appending to the end)
    ### The default file is log_dir/output/result.txt
    def print_result_to_file(self, filename='result.txt'):

        output_dir = self.log_dir + 'output'
        if (not os.path.exists(output_dir)): 
            os.makedirs(output_dir)

        result_file = open(output_dir + '/' + filename, 'a')

        result_file.writelines('-' * 20)
        result_file.writelines(time.asctime( time.localtime(time.time()) ))
        result_file.writelines('-' * 20 + '\n')
        result_file.writelines('Test duration: ' + str(self.network_statistics['test_duration'] / 1000) + ' seconds\n')
        result_file.writelines('Number of sensor (source) nodes: ' + str(len(self.src_node_list)) + '\n')
        result_file.writelines('Packet ID range: ' + str(self.min_pkt_id) + ' -> ' 
                               + str(self.max_pkt_id) + '\n')
        result_file.writelines('\n-----Node statistics-----\n')
        result_file.writelines('  NodeID   #Generated   #Delivered   AvgHops   AvgDelay   Delivery%   Throughput   Goodput\n')

        for src_node in self.src_node_list:
            result_file.writelines(('{:8d} {:12d} {:12d} {:9.2f} {:10.2f} {:11.2f} {:12.2f} {:9.2f}\n').format(src_node, 
                                    self.node_statistics[src_node]['num_pkts_generated_range'],
                                    self.node_statistics[src_node]['num_pkts_delivered_range'],
                                    self.node_statistics[src_node]['avg_hopcount'],
                                    self.node_statistics[src_node]['avg_delay'],
                                    self.node_statistics[src_node]['delivery_rate'] * 100,
                                    self.node_statistics[src_node]['throughput'],
                                    self.node_statistics[src_node]['goodput']))

        result_file.writelines('\n-----Network statistics-----\n')
        result_file.writelines('           #Generated   #Delivered   AvgHops   AvgDelay   Delivery%   Throughput   Goodput\n')
        result_file.writelines(('         {:12d} {:12d} {:9.2f} {:10.2f} {:11.2f} {:12.2f} {:9.2f}\n').format(
                                self.network_statistics['num_pkts_generated_range'],
                                self.network_statistics['num_pkts_delivered_range'],
                                self.network_statistics['avg_hopcount'],
                                self.network_statistics['avg_delay'],
                                self.network_statistics['delivery_rate'] * 100,
                                self.network_statistics['throughput'],
                                self.network_statistics['goodput']))
        result_file.writelines('\n\n')

        print 'The results have been written into the file:' 
        print '       ' + os.path.abspath(output_dir+'/'+filename)
        
        result_file.close()


    """ Analyze the paths of a packet
     
        Output: paths = [{'base_hopcount':..., 'path':...}, ...]
        
        The output is a list of the paths and branches on the packet routes.
        Each path has two keys. One key is 'path', a list of nodes on the
        path. The other key is 'base_hopcount', the number of hops that the 
        packet take to reach the first node of 'path'.

        Example: [{'base_hopcount': 0, 'path':[1, 2, 3, 4, 0]},
                  {'base_hopcount': 2, 'path':[3, 5, 0]}
                 ]
        This means that one duplicate of the packet travese through nodes
        1, 2, 3, 4 and then to the root node. The other duplicate of the
        packet is generated at node 3 and traverse through nodes 3, 5 and
        then to the root node.
    """    
    def analyze_packet_paths(self, src_node, pkt_id):

        trace = self.packets[src_node][pkt_id]['trace']
        trace.sort(key=operator.itemgetter(3))  # Sort by hopcount

        paths = [{'base_hopcount': 0, 'path':[src_node]}]
            
        for event_info in trace:

            node_added = False

            from_node = event_info[1]
            to_node   = event_info[0]
            hopcount = event_info[3]

            if (to_node == src_node):
                continue
            
            for path in paths:

                if (len(path['path']) + path['base_hopcount'] == hopcount 
                    and from_node == path['path'][-1]):

                    path['path'].append(to_node)
                    node_added = True

            if (node_added == False): 
                
                new_path = {'base_hopcount': hopcount-1, 'path': [from_node, to_node]}
                paths.append(new_path)

        return paths


    """ Analyze the paths of a packet (2nd version)
     
        Output: paths = [[a series of nodes], [a series of nodes], ...]

        Example: [[1, 2, 3, 4, 0],
                  [1, 2, 3, 5, 0]
                 ]
        This means that one duplicate of the packet travese through nodes
        1, 2, 3, 4 and then to the root node. The path of the other duplicate
        is 1, 2, 3, 5 and then to the root node.
    """    
    def analyze_packet_paths_v2(self, src_node, pkt_id):

        trace = self.packets[src_node][pkt_id]['trace']
        trace.sort(key=operator.itemgetter(3))  # Sort by hopcount

        paths = [[src_node]]
            
        for event_info in trace:

            new_path_generated = False

            from_node = event_info[1]
            to_node   = event_info[0]
            hopcount = event_info[3]

            if (to_node == src_node):
                continue
            
            for path in paths:

                if (len(path) == hopcount and from_node == path[-1]):

                    path.append(to_node)
                    break

                if (len(path) == hopcount + 1 and from_node == path[-2]):

                    new_path = path[:] # Create a deep copy
                    new_path[-1] = to_node
                    new_path_generated = True
                    break

            if (new_path_generated == True): 
                
                paths.append(new_path)

        return paths


    ###------------------------------------------------------------------------
    ### The functions for drawing delay histograms and visualization of network
    ### topology
    ###------------------------------------------------------------------------

    """ Draw the delay histogram for each node in the network:

        rows        = number of subplot rows
        cols        = number of subplot cols
        output_file = output file to write to. Automatic format detection (e.g. png, pdf, svg, ps)
        num_bins    = number of histogram bins
        font_size   = font size on the graph
        min_max     = cutoff for outliers. This will set the minimum and maximum the bins will hold
        axis        = force consistent axis on every plot in the order [X_min, X_max, Y_min, Y_max]
        normalized  = if true this will normalize everything to 1
    """
    def draw_delay_histogram(self, rows=None, cols=None, filename='delay_hist.png', num_bins=50,
                             font_size=5, min_max=None, axis=None, normalized=False):

        output_dir = self.log_dir + 'output'
        if (not os.path.exists(output_dir)): 
            os.makedirs(output_dir)

        if (rows == None and cols == None):

            rows = math.ceil(math.sqrt(len(self.src_node_list)))
            cols = math.ceil(math.sqrt(len(self.src_node_list)))

        cur_plot = 1

        fig = plt.figure()

        for src_node in self.src_node_list:

            delay = []

            for pkt_id in range(self.min_pkt_id, self.max_pkt_id):

                if (pkt_id in self.packets[src_node]):
                    if (self.packets[src_node][pkt_id]['delivered_count'] > 0):
                        delay.append(self.packets[src_node][pkt_id]['delay'])

            plt.subplot(rows, cols, cur_plot)

            if (min_max != None):
                n, bins, patches = plt.hist(delay, num_bins, range=min_max, normed=normalized, alpha=0.5)
            else:
                n, bins, patches = plt.hist(delay, num_bins, normed=normalized, alpha=0.5)

            if (axis != None):
                plt.axis(axis)
            
            plt.rcParams['font.size'] = float(font_size)
            plt.xlabel('Delay (ms)')
            plt.ylabel('Num packets')
            plt.grid(True)
            plt.title('Delay from node ' + str(src_node))
            tmp = plt.axis()
            plt.text(0.85 * tmp[1], 0.9 * tmp[3], ('Avg. Delay\n= %0.3f ms' % (sum(delay) / float(len(delay)))),
                     horizontalalignment='center', verticalalignment='center', fontsize=font_size)

            cur_plot += 1

        plt.savefig(output_dir+'/'+filename, dpi=300)
        print 'The delay histograms have been saved as the image:' 
        print '       ' + os.path.abspath(output_dir+'/'+filename)

    
    """ Create the images for each segment (window) of packets based on their traces and
        merge them into a video demonstrating the time-varying network topology
    """
    def create_topology_animation(self):

        output_dir = self.log_dir + 'output'
        if (not os.path.exists(output_dir)): 
            os.makedirs(output_dir)

        frame_dir = output_dir + '/frames'
        if (not os.path.exists(frame_dir)): 
            os.makedirs(frame_dir)

        if (os.path.exists(self.log_dir + 'animation_config')):
            self.parse_animation_config()
        else:
            print 'Warning: cannot find the file animation_config.'

        if (self.node_position == {}):

            print 'Warning: node positions are not configured.'
            print 'Assigning positions to the nodes uniformly randomly within the area.'

            width  = int(self.image_size.split(',')[0])
            height = int(self.image_size.split(',')[1])

            for src_node in self.src_node_list:
                self.node_position[src_node] = str(random.uniform(0,width)) + \
                                ',' + str(random.uniform(0,height)) 

            self.node_position[0] = str(random.uniform(0,width)) + ',' \
                           + str(random.uniform(0,height)) 
            self.node_position['lost'] = str(random.uniform(0,width)) + ',' \
                           + str(random.uniform(0,height))


        if (self.node_color == {}):

            print 'Warning: node colors are not configured.'
            print 'Assigning colors to the nodes randomly.'

            for src_node in self.src_node_list:
                self.node_color[src_node] = '#{0:6x}'.format(random.randint(0, 0xffffff))


        min_pkt_id   = self.min_pkt_id
        max_pkt_id   = self.max_pkt_id
        segment_size = self.segment_size

        num_segment = (max_pkt_id - min_pkt_id) / segment_size

        nodes = {}

        node_list = [0, 'lost']
        node_list.extend(self.src_node_list)
        for src_node in node_list:
            node = pydot.Node(str(src_node))
            node.set_shape('circle')
            node.set_pin('True')
            node.set_pos(self.node_position[src_node] + '!')
            nodes[src_node] = node

        self.init_progressbar()

        for segment_idx in range(0, num_segment): 
            
            start_pkt_id = min_pkt_id + segment_idx * segment_size
            end_pkt_id = min_pkt_id + (segment_idx+1) * segment_size

            graph = pydot.Dot(graph_type='digraph')

            for i in nodes:
                graph.add_node(nodes[i])

            for src_node in self.src_node_list:

                edges = self.create_edges(src_node, start_pkt_id, end_pkt_id)

                for node1 in edges:
                    for node2 in edges[node1]:
                        edge = pydot.Edge(nodes[node1], nodes[node2])
                        edge.set_label(str(edges[node1][node2]))
                        edge.set_color(self.node_color[src_node])
                        edge.set_fontcolor(self.node_color[src_node])
                        graph.add_edge(edge)

            graph.set_size(self.image_size + '!')
            graph.set_ratio('fill')
            graph.set_label('Packets ' + str(start_pkt_id) + ' to ' + str(end_pkt_id))

            graph.write_png(frame_dir + '/' + str(segment_idx).zfill(3) + '.png', prog='neato')

            self.update_progressbar(segment_idx, num_segment-1)


        if (self.image_only == False):

            print 'Merging the images into a video image... ',
            os.system('avconv -r 5 '+'-i '+self.log_dir+'output/frames/%03d.png -y '
                      +self.log_dir+'output/animation.mp4 > temp 2>&1')
            os.system('rm temp')
            print 'Done.'

            if (self.save_frame == False):
                print 'Removing the temporary image files... ',
                os.system('rm -r '+self.log_dir+'output/frames')
                print 'Done.'

            print 'The network topology animation has been generated:' 
            print '       ' + os.path.abspath(output_dir+'/'+'animation.mp4')
    

    ### Create the full topology for the whole range of packets from min_pkt_id to max_pkt_id
    def create_full_topology(self, filename='full_topology.png'):

        output_dir = self.log_dir + 'output'
        if (not os.path.exists(output_dir)): 
            os.makedirs(output_dir)

        if (os.path.exists(self.log_dir + 'animation_config')):
            self.parse_animation_config()
        else:
            print 'Warning: cannot find the file animation_config.'

        if (self.node_position == {}):

            print 'Warning: node positions are not configured.'
            print 'Assigning positions to the nodes uniformly randomly within the area.'

            width  = int(self.image_size.split(',')[0])
            height = int(self.image_size.split(',')[1])

            for src_node in self.src_node_list:
                self.node_position[src_node] = str(random.uniform(0,width)) + ',' + str(random.uniform(0,height))

            self.node_position[0] = str(random.uniform(0,width)) + ',' + str(random.uniform(0,height))
            self.node_position['lost'] = str(random.uniform(0,width)) + ',' + str(random.uniform(0,height))


        if (self.node_color == {}):

            print 'Warning: node colors are not configured.'
            print 'Assigning colors to the nodes randomly.'

            for src_node in self.src_node_list:
                self.node_color[src_node] = '#{0:x}'.format(random.randint(0, 0xffffff))

        nodes = {}

        node_list = [0, 'lost']
        node_list.extend(self.src_node_list)
        for src_node in node_list:
            node = pydot.Node(str(src_node))
            node.set_shape('circle')
            node.set_pin('True')
            node.set_pos(self.node_position[src_node] + '!')
            nodes[src_node] = node

        graph = pydot.Dot(graph_type='digraph')

        for i in nodes:
            graph.add_node(nodes[i])

        for src_node in self.src_node_list:

            edges = self.create_edges(src_node, self.min_pkt_id, self.max_pkt_id)

            for node1 in edges:
                for node2 in edges[node1]:
                    edge = pydot.Edge(nodes[node1], nodes[node2])
                    edge.set_label(str(edges[node1][node2]))
                    edge.set_color(self.node_color[src_node])
                    edge.set_fontcolor(self.node_color[src_node])
                    graph.add_edge(edge)

        graph.set_size(self.image_size + '!')
        graph.set_ratio('fill')
        graph.set_label('Packets ' + str(self.min_pkt_id) + ' to ' + str(self.max_pkt_id))

        graph.write_png(output_dir + '/' + filename, prog='neato')
        print 'The full network topology has been saved as the image:' 
        print '       ' + os.path.abspath(output_dir+'/'+filename)


    """ Calculating the number of packets (with the source node and packet
        ID within range [start_pkt_id, end_pkt_id]) traversing the edges:

        edges[start_id][end_id] = number of packets going that route
    """
    def create_edges(self, src_node, start_pkt_id, end_pkt_id):

        edges = {}

        for pkt_id in range(start_pkt_id, end_pkt_id):

            if (pkt_id in self.packets[src_node]):

                paths = self.analyze_packet_paths(src_node, pkt_id)

                for path in paths:

                    if (path['path'][-1] != 0):
                        path['path'].append('lost')

                ### Calculate how many times that the packets have traversed
                ### each edge
                for path in paths:

                    for i in range(0, len(path['path']) - 1):
                    
                        from_node = path['path'][i]
                        to_node   = path['path'][i+1]

                        if (from_node not in edges):
                            edges[from_node] = {}

                        if (to_node not in edges[from_node]):
                            edges[from_node][to_node] = 0

                        edges[from_node][to_node] += 1
                        
        return edges


    """ 2nd version

        Calculate the edge labels based on analyze_packet_paths_v2()
    """
    def create_edges_v2(self, src_node, start_pkt_id, end_pkt_id):

        edges = {}

        for pkt_id in range(start_pkt_id, end_pkt_id):

            if (pkt_id in self.packets[src_node]):

                paths = self.analyze_packet_paths_v2(src_node, pkt_id)

                for path in paths:
                    if (path[-1] != 0):
                        path.append('lost')

                ### Calculate how many times that the packets have traversed
                ### each edge
                for path in paths:

                    for i in range(0, len(path) - 1):
                    
                        from_node = path[i]
                        to_node   = path[i+1]

                        if (from_node not in edges):
                            edges[from_node] = {}

                        if (to_node not in edges[from_node]):
                            edges[from_node][to_node] = 0

                        edges[from_node][to_node] += 1
                        
        return edges


    """ 3rd version 

        This version does not use the paths of packets. This version sums up
        the binary indicator of whether a packet has traversed an edge. Thus
        this function only use the information (last_node, cur_node) and does
        not use the hop_count. If a packet traverses an edge back and forth
        multiple times, this function cannot calculate the number of the packet
        traversing the edge while the above two functions can.
    """
    def create_edges_v3(self, src_node, start_pkt_id, end_pkt_id):

        edges = {}

        for pkt_id in range(start_pkt_id, end_pkt_id):

            if (pkt_id in self.packets[src_node]):

                ### Collect all the edges that the packet has traversed
                routes = []

                for event_info in self.packets[src_node][pkt_id]['trace']:
                    
                    from_node = event_info[1]
                    to_node   = event_info[0]
                    edge      = (from_node, to_node)

                    if (to_node != src_node and edge not in routes):
                        routes.append(edge)

                ### Check whether each sensor node on the packet routes
                ### has the next hop. If not, it means that the packet
                ### is lost at this sensor node.
                lost_routes = []

                for edge1 in routes:

                    to_node = edge1[1]
                    next_hop_found = False 
                    
                    ### The root node is the last hop.
                    if (to_node == 0):
                        continue

                    for edge2 in routes:

                        if (edge2[0] == to_node):
                            next_hop_found = True
                            break

                    if (next_hop_found == False):
                        lost_routes.append((to_node, 'lost'))

                routes.extend(lost_routes)

                ### Calculate how many times that the packets have traversed
                ### each edge
                for edge in routes:
                    
                    from_node = edge[0]
                    to_node   = edge[1]

                    if (from_node not in edges):
                        edges[from_node] = {}

                    if (to_node not in edges[from_node]):
                        edges[from_node][to_node] = 0

                    edges[from_node][to_node] += 1
                        
        return edges


    ### Parse the file log_dir/animation_config to extract the information of
    ### node positions, colors, etc.
    def parse_animation_config(self):
        
        config_file = open(self.log_dir + 'animation_config', 'r')

        line = config_file.readline() 

        while line != '':

            if (line.startswith('<node_position>')):

                line = config_file.readline().strip()

                while not line.startswith('</node_position>'):

                    s = line.split()

                    if s[0] != 'lost':
                        node_id = int(s[0])
                        pos = s[1]
                        self.node_position[node_id] = pos 
                    else:
                        self.node_position['lost'] = s[1]

                    line = config_file.readline().strip()


            if (line.startswith('<node_color>')):

                line = config_file.readline().strip()
                idx = 0

                while not line.startswith('</node_color>'):
                    if (idx < len(self.src_node_list)):
                        self.node_color[self.src_node_list[idx]] = line
                        idx += 1
                    line = config_file.readline().strip()


            if line.startswith('<image_size>'):

                line = config_file.readline().strip()

                while not line.startswith('</image_size>'):
                    self.image_size = line
                    line = config_file.readline().strip()


            if line.startswith('<segment_size>'):

                line = config_file.readline().strip()

                while not line.startswith('</segment_size>'):
                    self.segment_size = int(line)
                    line = config_file.readline().strip()


            if line.startswith('<save_frame>'):

                line = config_file.readline().strip()

                while not line.startswith('</save_frame>'):
                    if (line == 'True'):
                        self.save_frame = True
                    else:
                        self.save_frame = False
                    line = config_file.readline().strip()


            if line.startswith('<image_only>'):

                line = config_file.readline().strip()

                while not line.startswith('</image_only>'):
                    if (line == 'True'):
                        self.image_only = True
                    else:
                        self.image_only = False
                    line = config_file.readline().strip()

            line = config_file.readline()

        config_file.close()


    def init_progressbar(self):

        ### For visualizing the progress of generating images
        sys.stdout.write('Generating images: [%s]' % (' ' * 50))
        sys.stdout.flush()
        sys.stdout.write('\b' * (51))


    def update_progressbar(self, idx, size):

        if (idx != size):

            progress = int(math.floor(50 * idx / size))
            sys.stdout.write('=' * progress)
            sys.stdout.flush()
            sys.stdout.write('\b' * progress)

        else:

            progress = int(math.floor(50 * idx / size))
            sys.stdout.write('=' * progress + '] Done.\n')
            
